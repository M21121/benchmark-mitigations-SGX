=== Directory Structure ===
.
├── app_config.cpp
├── app.cpp
├── benchmark_script.sh
├── enclave.config.xml
├── enclave.cpp
├── enclave.edl
├── enclave_private.pem
├── Makefile
├── mitigation_config.h
├── mitigations.cpp
└── mitigations.h

1 directory, 11 files

=== Code Files ===


### File: ./app_config.cpp ###

//app_config.cpp - Defines the global app-side configuration object.
#include "mitigation_config.h"

// App-side global config, accessible by app.cpp
MitigationConfig g_app_config;

// Use a constructor attribute to ensure this runs before main()
// This initializes the global config with default values (all false).
__attribute__((constructor))
void init_app_config() {
    init_mitigation_config(&g_app_config);
}
-------------------


### File: ./benchmark_script.sh ###

#!/bin/bash
# benchmark_script.sh

ITERATIONS=1000
OUTPUT="benchmark_results.csv"

echo "test_type,mitigations,iterations,total_time_ms,time_per_op_us" > $OUTPUT

echo "Creating test file..."
dd if=/dev/urandom of=test.txt bs=1024 count=100 2>/dev/null

TESTS=("ecall" "pure_ocall" "pingpong" "fileread" "sgxread")

# Updated mitigation sets to include individual speculation barriers
MITIGATION_SETS=(
    "none"
    "lfence"
    "mfence"
    "cpuid"
    "lfence,mfence"
    "lfence,cpuid"
    "mfence,cpuid"
    "all_speculation"
    "speculation"
    "cache"
    "timing"
    "constant"
    "memory"
    "hyperthreading"
    "speculation,cache"
    "speculation,timing"
    "cache,timing"
    "all"
)

make clean
make SGX_MODE=1

if [ $? -ne 0 ]; then
    echo "✗ Build failed. Aborting benchmark."
    exit 1
fi

echo "✓ Build successful. Starting benchmarks..."

for test in "${TESTS[@]}"; do
    for mitigations in "${MITIGATION_SETS[@]}"; do
        echo "-----------------------------------------------------"
        echo "Running test: '$test' with mitigations: '$mitigations'"

        if ./app -t "$test" -i "$ITERATIONS" -m "$mitigations" -o "$OUTPUT"; then
            echo "✓ Completed"
        else
            echo "✗ FAILED"
        fi
    done
done

echo "Benchmark complete. Results in $OUTPUT"
echo ""
echo "Speculation barrier test summary:"
echo "- lfence: Load fence barrier only"
echo "- mfence: Memory fence barrier only"
echo "- cpuid: CPUID serializing instruction only"
echo "- lfence,mfence: Both load and memory fences"
echo "- lfence,cpuid: Load fence + CPUID"
echo "- mfence,cpuid: Memory fence + CPUID"
echo "- all_speculation: All three barriers (lfence+mfence+cpuid)"
echo "- speculation: Legacy combined barrier (lfence+mfence+cpuid in sequence)"

-------------------


### File: ./enclave.edl ###

enclave {
    // Import the shared mitigation configuration structure
    include "mitigation_config.h"

    // Trusted functions (ECALLs) that can be called from the untrusted app
    trusted {
        public void ecall_warmup(); 

        // Receives mitigation settings from the app
        public void ecall_set_mitigation_config([in] const MitigationConfig* config);

        // A minimal ECALL to measure transition overhead
        public void ecall_empty();

        // ECALL to trigger an OCALL for benchmarking
        public void ecall_trigger_ocall();

        // ECALL for the ping-pong test
        public void ecall_ping(int iteration);

        // ECALLs for file I/O tests
        public void ecall_file_read([in, string] const char* filename);
        public void ecall_sgx_file_read([in, string] const char* filename);
    };

    // Untrusted functions (OCALLs) that can be called from within the enclave
    untrusted {
        // A minimal OCALL
        void empty_ocall();

        // OCALL to print a string to the console
        void ocall_print_string([in, string] const char* str);

        // OCALL for the ping-pong test
        void pong_ocall(int iteration);

        // OCALL to read a file into the enclave's buffer
        size_t ocall_read_file([in, string] const char* filename,
                               [out, size=buf_len] char* buf,
                               size_t buf_len);
    };
};
-------------------


### File: ./app.cpp ###

// app.cpp
#include <iostream>
#include <vector>
#include <string>
#include <chrono>
#include <sched.h>
#include <unistd.h>
#include <getopt.h>
#include <fstream>
#include "sgx_urts.h"
#include "enclave_u.h"
#include "mitigation_config.h"

// Declare the app-side config, defined in app_config.cpp
extern MitigationConfig g_app_config;

sgx_enclave_id_t global_eid = 0;

// Forward declaration
void set_mitigation_flag(const std::string& flag);

class BenchmarkRunner {
private:
    std::vector<int> physical_cores;

    // Helper to identify physical cores (assumes hyperthreading is paired on adjacent cores)
    void get_physical_cores() {
        long num_cores_long = sysconf(_SC_NPROCESSORS_ONLN);
        int num_cores = static_cast<int>(num_cores_long);
        // This simple logic assumes core 0, 2, 4... are physical cores
        for (int i = 0; i < num_cores; i += 2) {
            physical_cores.push_back(i);
        }
    }

    // Pin the current thread to a specific physical core to mitigate hyperthreading effects
    void pin_to_physical_core() {
        if (physical_cores.empty()) get_physical_cores();

        if (physical_cores.empty()) {
            std::cerr << "Warning: Could not determine physical cores." << std::endl;
            return;
        }

        cpu_set_t cpuset;
        CPU_ZERO(&cpuset);
        CPU_SET(physical_cores[0], &cpuset);

        if (sched_setaffinity(0, sizeof(cpuset), &cpuset) == 0) {
            std::cout << "Pinned to physical core " << physical_cores[0] << std::endl;
        } else {
            std::cerr << "Warning: Failed to pin to physical core." << std::endl;
        }
    }

public:
    // Set up environment based on configuration, like pinning cores
    void setup_environment() {
        if (g_app_config.disable_hyperthreading) {
            pin_to_physical_core();
        }
        // Send the final configuration into the enclave
        ecall_set_mitigation_config(global_eid, &g_app_config);
    }

    // Benchmark a minimal ECALL to measure transition overhead + enabled mitigations
    double benchmark_empty_ecall(int iterations) {
        auto start = std::chrono::high_resolution_clock::now();
        for (int i = 0; i < iterations; i++) {
            ecall_empty(global_eid);
        }
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        return static_cast<double>(duration.count()) / 1000.0;
    }

    // Correctly benchmark an OCALL by triggering it from within the enclave
    double benchmark_pure_ocall(int iterations) {
        auto start = std::chrono::high_resolution_clock::now();
        for (int i = 0; i < iterations; i++) {
            ecall_trigger_ocall(global_eid);
        }
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        return static_cast<double>(duration.count()) / 1000.0;
    }

    // Benchmark an ECALL that immediately makes an OCALL back to the app
    double benchmark_ping_pong(int iterations) {
        auto start = std::chrono::high_resolution_clock::now();
        for (int i = 0; i < iterations; i++) {
            ecall_ping(global_eid, i);
        }
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        return static_cast<double>(duration.count()) / 1000.0;
    }

    // Benchmark file reading via an OCALL
    double benchmark_file_read(const std::string& filename, int iterations) {
        auto start = std::chrono::high_resolution_clock::now();
        for (int i = 0; i < iterations; i++) {
            ecall_file_read(global_eid, filename.c_str());
        }
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        return static_cast<double>(duration.count()) / 1000.0;
    }

    // Benchmark file reading with SGX-specific data processing mitigations
    double benchmark_sgx_file_read(const std::string& filename, int iterations) {
        auto start = std::chrono::high_resolution_clock::now();
        for (int i = 0; i < iterations; i++) {
            ecall_sgx_file_read(global_eid, filename.c_str());
        }
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        return static_cast<double>(duration.count()) / 1000.0;
    }
};

// Helper function to set a specific mitigation flag
void set_mitigation_flag(const std::string& flag) {
    if (flag == "lfence") g_app_config.lfence_barrier = true;
    else if (flag == "mfence") g_app_config.mfence_barrier = true;
    else if (flag == "cpuid") g_app_config.cpuid_barrier = true;
    else if (flag == "speculation") g_app_config.speculation_barriers = true;
    else if (flag == "cache") g_app_config.cache_flushing = true;
    else if (flag == "timing") g_app_config.timing_noise = true;
    else if (flag == "constant") g_app_config.constant_time_ops = true;
    else if (flag == "memory") g_app_config.memory_barriers = true;
    else if (flag == "hyperthreading") g_app_config.disable_hyperthreading = true;
}

void parse_mitigations(const std::string& mitigation_str) {
    init_mitigation_config(&g_app_config);

    if (mitigation_str.empty() || mitigation_str == "none") return;
    if (mitigation_str == "all") {
        g_app_config.speculation_barriers = true;
        g_app_config.cache_flushing = true;
        g_app_config.timing_noise = true;
        g_app_config.constant_time_ops = true;
        g_app_config.memory_barriers = true;
        g_app_config.disable_hyperthreading = true;
        return;
    }
    if (mitigation_str == "all_speculation") {
        g_app_config.lfence_barrier = true;
        g_app_config.mfence_barrier = true;
        g_app_config.cpuid_barrier = true;
        return;
    }

    std::string current_token;
    std::string remaining = mitigation_str + ",";
    size_t pos = 0;
    while ((pos = remaining.find(',')) != std::string::npos) {
        current_token = remaining.substr(0, pos);
        if (!current_token.empty()) {
            set_mitigation_flag(current_token);
        }
        remaining.erase(0, pos + 1);
    }
}

void print_config() {
    std::cout << "Current mitigation configuration:\n";
    std::cout << "  LFENCE barrier:       " << (g_app_config.lfence_barrier ? "ON" : "OFF") << "\n";
    std::cout << "  MFENCE barrier:       " << (g_app_config.mfence_barrier ? "ON" : "OFF") << "\n";
    std::cout << "  CPUID barrier:        " << (g_app_config.cpuid_barrier ? "ON" : "OFF") << "\n";
    std::cout << "  Speculation barriers: " << (g_app_config.speculation_barriers ? "ON" : "OFF") << "\n";
    std::cout << "  Cache flushing:       " << (g_app_config.cache_flushing ? "ON" : "OFF") << "\n";
    std::cout << "  Timing noise:         " << (g_app_config.timing_noise ? "ON" : "OFF") << "\n";
    std::cout << "  Constant time ops:    " << (g_app_config.constant_time_ops ? "ON" : "OFF") << "\n";
    std::cout << "  Memory barriers:      " << (g_app_config.memory_barriers ? "ON" : "OFF") << "\n";
    std::cout << "  Disable hyperthreading: " << (g_app_config.disable_hyperthreading ? "ON" : "OFF") << "\n";
}

// --- OCALL Implementations ---
// These functions are called by the enclave to interact with the untrusted app

// OCALL to perform some work, ensuring the OCALL transition itself is measured
void empty_ocall() {
    // Perform a small amount of volatile work to prevent this from being optimized away
    volatile int result = 0;
    for (int i = 0; i < 100; i++) {
        result += i;
    }
}

// OCALL to print a string from the enclave
void ocall_print_string(const char* str) {
    // Using printf for direct output. In a real app, use a safer logging mechanism.
    printf("%s", str);
}

// OCALL part of the ping-pong test
void pong_ocall(int iteration) {
    // This OCALL intentionally does nothing but return, to measure the transition
}

// OCALL to read a file from the untrusted filesystem
size_t ocall_read_file(const char* filename, char* buf, size_t buf_len) {
    FILE* file = fopen(filename, "rb");
    if (!file) return 0;

    size_t bytes_read = fread(buf, 1, buf_len, file);
    fclose(file);
    return bytes_read;
}

// Initializes the SGX enclave
int initialize_enclave() {
    sgx_status_t ret;
    sgx_launch_token_t token = {0};
    int updated = 0;

    ret = sgx_create_enclave("enclave.signed.so", SGX_DEBUG_FLAG, &token, &updated, &global_eid, nullptr);
    return (ret == SGX_SUCCESS) ? 0 : -1;
}

void print_usage(const char* program) {
    std::cout << "Usage: " << program << " [options]\n";
    std::cout << "Options:\n";
    std::cout << "  -t, --test TYPE          Test type (ecall, pure_ocall, pingpong, fileread, sgxread)\n";
    std::cout << "  -i, --iterations N       Number of iterations (default: 1000)\n";
    std::cout << "  -f, --file FILE          File for read tests (default: test.txt)\n";
    std::cout << "  -m, --mitigations LIST   Comma-separated mitigations (e.g., speculation,cache,all,none)\n";
    std::cout << "  -o, --output FILE        Output CSV file\n";
    std::cout << "  -h, --help               Show this help\n";
}

int main(int argc, char* argv[]) {
    std::string test_type;
    int iterations = 1000;
    std::string filename = "test.txt";
    std::string output_file;
    std::string mitigations = "none";

    static struct option long_options[] = {
        {"test", required_argument, 0, 't'},
        {"iterations", required_argument, 0, 'i'},
        {"file", required_argument, 0, 'f'},
        {"mitigations", required_argument, 0, 'm'},
        {"output", required_argument, 0, 'o'},
        {"help", no_argument, 0, 'h'},
        {0, 0, 0, 0}
    };

    int opt;
    while ((opt = getopt_long(argc, argv, "t:i:f:m:o:h", long_options, nullptr)) != -1) {
        switch (opt) {
            case 't': test_type = optarg; break;
            case 'i': iterations = std::stoi(optarg); break;
            case 'f': filename = optarg; break;
            case 'm': mitigations = optarg; break;
            case 'o': output_file = optarg; break;
            case 'h': print_usage(argv[0]); return 0;
            default: print_usage(argv[0]); return 1;
        }
    }

    if (test_type.empty()) {
        std::cerr << "Error: Test type required\n";
        print_usage(argv[0]);
        return 1;
    }

    parse_mitigations(mitigations);
    print_config();

    if (initialize_enclave() < 0) {
        std::cerr << "Failed to initialize enclave\n";
        return 1;
    }

    BenchmarkRunner runner;
    runner.setup_environment();

    // --- WARM-UP PHASE ---
    // Run the warm-up ECALL a number of times to stabilize the CPU frequency.
    std::cout << "Warming up CPU..." << std::endl;
    for (int i = 0; i < 200; ++i) { // Run many iterations
         ecall_warmup(global_eid);
    }
    std::cout << "Warm-up complete. Starting benchmark." << std::endl;
    // --- END WARM-UP PHASE ---

    double time_ms = 0;

    if (test_type == "ecall") {
        time_ms = runner.benchmark_empty_ecall(iterations);
    } else if (test_type == "pure_ocall") {
        time_ms = runner.benchmark_pure_ocall(iterations);
    } else if (test_type == "pingpong") {
        time_ms = runner.benchmark_ping_pong(iterations);
    } else if (test_type == "fileread") {
        time_ms = runner.benchmark_file_read(filename, iterations);
    } else if (test_type == "sgxread") {
        time_ms = runner.benchmark_sgx_file_read(filename, iterations);
    } else {
        std::cerr << "Unknown test type: " << test_type << "\n";
        sgx_destroy_enclave(global_eid);
        return 1;
    }

    double time_per_op = (time_ms * 1000.0) / iterations;
    std::cout << "Results: " << time_ms << "ms total, " << time_per_op << "μs per operation\n";

    if (!output_file.empty()) {
        std::ofstream csv(output_file, std::ios::app);
        csv << test_type << "," << mitigations << "," << iterations << ","
            << time_ms << "," << time_per_op << "\n";
    }

    sgx_destroy_enclave(global_eid);
    return 0;
}
-------------------


### File: ./mitigations.cpp ###

// mitigations.cpp
#include "mitigations.h"
#include "sgx_trts.h"
#include <string.h>

static MitigationConfig g_enclave_config;

void set_enclave_config(const MitigationConfig* config) {
    if (config) {
        g_enclave_config = *config;
    }
}

namespace mitigations {
    const size_t CACHE_LINE_SIZE = 64;

    void speculation_barrier() {
        // Legacy function - use all barriers if enabled
        if (g_enclave_config.speculation_barriers) {
            __asm__ volatile (
                "lfence\n\t"
                "mfence\n\t"
                "cpuid\n\t"
                ::: "memory", "eax", "ebx", "ecx", "edx"
            );
            return;
        }

        // Use individual barriers
        if (g_enclave_config.lfence_barrier) {
            __asm__ volatile ("lfence" ::: "memory");
        }
        if (g_enclave_config.mfence_barrier) {
            __asm__ volatile ("mfence" ::: "memory");
        }
        if (g_enclave_config.cpuid_barrier) {
            __asm__ volatile (
                "cpuid"
                ::: "memory", "eax", "ebx", "ecx", "edx"
            );
        }
    }

    void cache_flush(const void* addr, size_t size) {
        if (!g_enclave_config.cache_flushing) return;
        const char* ptr = static_cast<const char*>(addr);
        for (size_t i = 0; i < size; i += CACHE_LINE_SIZE) {
            __asm__ volatile ("clflush %0" : "+m" (*(volatile char *)(ptr + i)));
        }
        __asm__ volatile ("mfence" ::: "memory");
    }

    void timing_noise() {
        if (!g_enclave_config.timing_noise) return;
        uint32_t delay_iterations = get_random_delay();
        volatile uint64_t dummy = 0;
        for (uint32_t i = 0; i < delay_iterations; i++) {
            dummy += i;
        }
    }

    void memory_barrier() {
        if (!g_enclave_config.memory_barriers) return;
        __asm__ volatile ("mfence" ::: "memory");
    }

    void constant_time_memcpy(void* dest, const void* src, size_t n) {
        if (!g_enclave_config.constant_time_ops) {
            memcpy(dest, src, n);
            return;
        }
        volatile unsigned char* d = static_cast<volatile unsigned char*>(dest);
        const volatile unsigned char* s = static_cast<const volatile unsigned char*>(src);
        for (size_t i = 0; i < n; i++) {
            d[i] = s[i];
        }
    }

    void secure_memzero(void* ptr, size_t len) {
        if (!g_enclave_config.constant_time_ops) {
            memset(ptr, 0, len);
            return;
        }
        cache_flush(ptr, len);
        volatile unsigned char* p = static_cast<volatile unsigned char*>(ptr);
        for (size_t i = 0; i < len; i++) {
            p[i] = 0;
        }
        cache_flush(ptr, len);
    }

    uint32_t get_random_delay() {
        uint32_t noise;
        sgx_status_t ret = sgx_read_rand(reinterpret_cast<unsigned char*>(&noise), sizeof(noise));
        if (ret != SGX_SUCCESS) {
            return 100;
        }
        return (noise % 500) + 50;
    }
}

-------------------


### File: ./mitigations.h ###

// mitigations.h
#ifndef MITIGATIONS_H
#define MITIGATIONS_H

#include "mitigation_config.h"
#include <stddef.h>

namespace mitigations {
    void lfence_barrier();
    void mfence_barrier();
    void cpuid_barrier();
    void speculation_barrier();
    void cache_flush(const void* addr, size_t size);
    void timing_noise();
    void memory_barrier();
    void constant_time_memcpy(void* dest, const void* src, size_t n);
    void secure_memzero(void* ptr, size_t len);
    uint32_t get_random_delay();
}

#endif // MITIGATIONS_H

-------------------


### File: ./mitigation_config.h ###

// mitigation_config.h
#ifndef MITIGATION_CONFIG_H
#define MITIGATION_CONFIG_H

#include <stdint.h>
#include <stdbool.h>

typedef struct {
    // Individual speculation barriers
    bool lfence_barrier;
    bool mfence_barrier;
    bool cpuid_barrier;

    // Other existing mitigations
    bool cache_flushing;
    bool timing_noise;
    bool constant_time_ops;
    bool memory_barriers;
    bool disable_hyperthreading;

    // Legacy flag for backward compatibility
    bool speculation_barriers;
} MitigationConfig;

static inline void init_mitigation_config(MitigationConfig* config) {
    if (config) {
        config->lfence_barrier = false;
        config->mfence_barrier = false;
        config->cpuid_barrier = false;
        config->cache_flushing = false;
        config->timing_noise = false;
        config->constant_time_ops = false;
        config->memory_barriers = false;
        config->disable_hyperthreading = false;
        config->speculation_barriers = false;
    }
}

#ifdef __cplusplus
extern "C" {
#endif

void set_enclave_config(const MitigationConfig* config);

#ifdef __cplusplus
}
#endif

#endif // MITIGATION_CONFIG_H

-------------------


### File: ./enclave.cpp ###

// enclave.cpp
#include "enclave_t.h"
#include "mitigations.h"

// A simple, stable workload to ensure the CPU is doing real work.
// The `volatile` keyword is crucial to prevent the compiler from optimizing this away.
void perform_stable_workload() {
    volatile int counter = 0;
    for (int i = 0; i < 2000; ++i) {
        counter += i % 123;
    }
}

// A dedicated warm-up function. Call this before the benchmark timer starts.
void ecall_warmup() {
    perform_stable_workload();
}

void ecall_set_mitigation_config(const MitigationConfig* config) {
    set_enclave_config(config);
}

// ecall_empty now includes a stable workload
void ecall_empty() {
    mitigations::speculation_barrier();
    mitigations::timing_noise();

    perform_stable_workload(); // <-- ADDED WORKLOAD

    mitigations::memory_barrier();
}

// The OCALL trigger also performs the workload
void ecall_trigger_ocall() {
    perform_stable_workload(); // <-- ADDED WORKLOAD
    empty_ocall();
}

// The ECALL side of the ping-pong test.
void ecall_ping(int iteration) {
    mitigations::speculation_barrier();
    mitigations::timing_noise();

    pong_ocall(iteration); // Make an OCALL back to the app

    mitigations::timing_noise();
}

// Helper to process a buffer of data with potential mitigations
void process_buffer(char* buffer, size_t bytes_read) {
    uint32_t checksum = 0;
    // This loop simulates processing the data read from the file
    for (size_t i = 0; i < bytes_read; i++) {
        checksum += (unsigned char)buffer[i];
        // Apply speculation barriers periodically if enabled to mitigate side-channel
        // leakage from data access patterns.
        if (i % 64 == 0) {
            mitigations::speculation_barrier();
        }
    }

    // Mitigations applied after processing
    mitigations::cache_flush(buffer, bytes_read);
    mitigations::secure_memzero(buffer, bytes_read); // Uses constant_time_ops and cache_flush internally
}

// ECALL to test file reading. The actual file I/O happens via an OCALL.
void ecall_file_read(const char* filename) {
    mitigations::speculation_barrier();
    mitigations::timing_noise();

    char buffer[8192] = {0};
    size_t bytes_read = 0;

    mitigations::cache_flush(buffer, sizeof(buffer)); // Flush before OCALL

    // OCALL to the app to read the file into the enclave's buffer
    ocall_read_file(&bytes_read, filename, buffer, sizeof(buffer));

    if (bytes_read > 0) {
        process_buffer(buffer, bytes_read);
    }

    mitigations::timing_noise();
}

// This function is identical to ecall_file_read for this benchmark's purpose.
// In a real application, it might use SGX-specific APIs or sealed data.
void ecall_sgx_file_read(const char* filename) {
    mitigations::speculation_barrier();
    mitigations::timing_noise();

    char buffer[8192] = {0};
    size_t bytes_read = 0;

    mitigations::cache_flush(buffer, sizeof(buffer));

    ocall_read_file(&bytes_read, filename, buffer, sizeof(buffer));

    if (bytes_read > 0) {
        process_buffer(buffer, bytes_read);
    }

    mitigations::timing_noise();
}
-------------------


### File: Makefile ###

# Makefile for SGX Mitigation Benchmarking System

SGX_SDK ?= /opt/intel/sgxsdk
SGX_MODE ?= HW
SGX_ARCH ?= x64
SGX_DEBUG ?= 1

ifeq ($(shell getconf LONG_BIT), 32)
	SGX_ARCH := x86
else ifeq ($(findstring -m32, $(CXXFLAGS)), -m32)
	SGX_ARCH := x86
endif

ifeq ($(SGX_ARCH), x86)
	SGX_COMMON_FLAGS := -m32
	SGX_LIBRARY_PATH := $(SGX_SDK)/lib
	SGX_ENCLAVE_SIGNER := $(SGX_SDK)/bin/x86/sgx_sign
	SGX_EDGER8R := $(SGX_SDK)/bin/x86/sgx_edger8r
else
	SGX_COMMON_FLAGS := -m64
	SGX_LIBRARY_PATH := $(SGX_SDK)/lib64
	SGX_ENCLAVE_SIGNER := $(SGX_SDK)/bin/x64/sgx_sign
	SGX_EDGER8R := $(SGX_SDK)/bin/x64/sgx_edger8r
endif

# Compiler settings
CXX := g++
CC := gcc

# Debug/Release flags
ifeq ($(SGX_DEBUG), 1)
	SGX_COMMON_FLAGS += -O0 -g -DDEBUG -UNDEBUG -UEDEBUG
else
	SGX_COMMON_FLAGS += -O2 -DNDEBUG -UEDEBUG -UDEBUG
endif

# Base compilation flags
SGX_COMMON_FLAGS += -Wall -Wextra -Winit-self -Wpointer-arith -Wreturn-type \
	-Waddress -Wsequence-point -Wformat-security -Wmissing-include-dirs \
	-Wfloat-equal -Wundef -Wshadow -Wcast-align -Wcast-qual -Wconversion \
	-Wredundant-decls

SGX_COMMON_CFLAGS := $(SGX_COMMON_FLAGS) -Wjump-misses-init -Wstrict-prototypes -std=c11
SGX_COMMON_CXXFLAGS := $(SGX_COMMON_FLAGS) -Wnon-virtual-dtor -std=c++14

# Security flags
SECURITY_FLAGS := -fstack-protector-strong -fPIE -fPIC -D_FORTIFY_SOURCE=2 \
	-Wl,-z,relro -Wl,-z,now -Wl,-z,noexecstack

# Check for retpoline support
RETPOLINE_SUPPORTED := $(shell echo 'int main(){}' | $(CC) -mindirect-branch=thunk -x c - -o /dev/null 2>/dev/null && echo yes || echo no)
ifeq ($(RETPOLINE_SUPPORTED),yes)
	RETPOLINE_FLAGS := -mindirect-branch=thunk -mfunction-return=thunk
else
	RETPOLINE_FLAGS :=
endif

######## App Settings ########
App_Cpp_Files := app.cpp app_config.cpp
App_Include_Paths := -I$(SGX_SDK)/include -I.
App_C_Flags := $(SGX_COMMON_CFLAGS) $(SECURITY_FLAGS) $(App_Include_Paths)
App_Cpp_Flags := $(SGX_COMMON_CXXFLAGS) $(SECURITY_FLAGS) $(App_Include_Paths)
App_Link_Flags := $(SGX_COMMON_FLAGS) $(SECURITY_FLAGS) -L$(SGX_LIBRARY_PATH) \
	-lsgx_urts -lpthread

ifneq ($(SGX_MODE), HW)
	App_Link_Flags += -lsgx_uae_service_sim
else
	App_Link_Flags += -lsgx_uae_service
endif

######## Enclave Settings ########
Enclave_Cpp_Files := enclave.cpp mitigations.cpp
Enclave_Include_Paths := -I$(SGX_SDK)/include -I$(SGX_SDK)/include/tlibc \
	-I$(SGX_SDK)/include/libcxx -I.

Enclave_C_Flags := $(SGX_COMMON_CFLAGS) -nostdinc -fvisibility=hidden -fpie \
	-fno-builtin-printf $(Enclave_Include_Paths)
Enclave_Cpp_Flags := $(SGX_COMMON_CXXFLAGS) -nostdinc++ -fvisibility=hidden -fpie \
	-fno-builtin-printf $(Enclave_Include_Paths)

# Add retpoline to enclave if supported
Enclave_C_Flags += $(RETPOLINE_FLAGS)
Enclave_Cpp_Flags += $(RETPOLINE_FLAGS)

Enclave_Link_Flags := $(SGX_COMMON_FLAGS) -Wl,--no-undefined -nostdlib \
	-nodefaultlibs -nostartfiles -L$(SGX_LIBRARY_PATH) \
	-Wl,--whole-archive -lsgx_trts -Wl,--no-whole-archive \
	-Wl,--start-group -lsgx_tstdc -lsgx_tcxx -lsgx_tcrypto -lsgx_tservice -Wl,--end-group \
	-Wl,-Bstatic -Wl,-Bsymbolic -Wl,--no-undefined \
	-Wl,-pie,-eenclave_entry -Wl,--export-dynamic \
	-Wl,--defsym,__ImageBase=0 -Wl,--gc-sections

# File names
App_Name := app
Enclave_Name := enclave.so
Signed_Enclave_Name := enclave.signed.so
Enclave_Config_File := enclave.config.xml

# Generated files
Generated_Files := enclave_u.c enclave_u.h enclave_t.c enclave_t.h

# Object files
App_Objects := app.o app_config.o enclave_u.o
Enclave_Objects := enclave.o mitigations.o enclave_t.o

# Intermediate files for cleanup
Intermediate_Files := $(Generated_Files) $(App_Objects) $(Enclave_Objects) $(Enclave_Name)

.PHONY: all clean clean-all run-tests help install-deps check-sgx

# Default target
all: $(App_Name) $(Signed_Enclave_Name)

######## EDL Generation ########
$(Generated_Files): enclave.edl
	@echo "Generating edge routines..."
	@$(SGX_EDGER8R) --untrusted enclave.edl --search-path $(SGX_SDK)/include
	@$(SGX_EDGER8R) --trusted enclave.edl --search-path $(SGX_SDK)/include
	@echo "GEN  =>  $(Generated_Files)"

######## App Objects ########
app_config.o: app_config.cpp mitigation_config.h
	@$(CXX) $(App_Cpp_Flags) -c $< -o $@
	@echo "CXX  <=  $<"

app.o: app.cpp enclave_u.h mitigation_config.h
	@$(CXX) $(App_Cpp_Flags) -c $< -o $@
	@echo "CXX  <=  $<"

enclave_u.o: enclave_u.c
	@$(CC) $(App_C_Flags) -c $< -o $@
	@echo "CC   <=  $<"

######## App Binary ########
$(App_Name): $(App_Objects)
	@$(CXX) $^ -o $@ $(App_Link_Flags)
	@echo "LINK =>  $@"

######## Enclave Objects ########
enclave_t.o: enclave_t.c
	@$(CC) $(Enclave_C_Flags) -c $< -o $@
	@echo "CC   <=  $<"

mitigations.o: mitigations.cpp mitigations.h mitigation_config.h enclave_t.h
	@$(CXX) $(Enclave_Cpp_Flags) -c $< -o $@
	@echo "CXX  <=  $<"

enclave.o: enclave.cpp enclave_t.h mitigations.h mitigation_config.h
	@$(CXX) $(Enclave_Cpp_Flags) -c $< -o $@
	@echo "CXX  <=  $<"

######## Enclave Binary ########
$(Enclave_Name): $(Enclave_Objects)
	@$(CXX) $^ -o $@ $(Enclave_Link_Flags)
	@echo "LINK =>  $@"

######## Signed Enclave ########
$(Signed_Enclave_Name): $(Enclave_Name) $(Enclave_Config_File)
	@$(SGX_ENCLAVE_SIGNER) sign -key enclave_private.pem -enclave $(Enclave_Name) \
		-out $@ -config $(Enclave_Config_File)
	@echo "SIGN =>  $@"

######## Test Targets ########
test-files:
	@echo "Creating test files..."
	@dd if=/dev/urandom of=test.txt bs=1024 count=100 status=none 2>/dev/null
	@dd if=/dev/urandom of=large_test.txt bs=1024 count=1024 status=none 2>/dev/null
	@echo "Created test.txt (100KB) and large_test.txt (1MB)"

test-basic: $(App_Name) $(Signed_Enclave_Name) test-files
	@echo "Running basic functionality tests..."
	@./$(App_Name) -t ecall -i 10 -m none
	@./$(App_Name) -t ocall -i 10 -m none
	@./$(App_Name) -t pingpong -i 5 -m none
	@./$(App_Name) -t fileread -i 5 -m none -f test.txt
	@echo "Basic tests completed successfully"

benchmark: $(App_Name) $(Signed_Enclave_Name) test-files
	@echo "Running comprehensive benchmark..."
	@chmod +x benchmark_script.sh
	@./benchmark_script.sh
	@echo "Benchmark completed. Results in benchmark_results.csv"

test-mitigations: $(App_Name) $(Signed_Enclave_Name) test-files
	@echo "Testing individual mitigations..."
	@echo "Testing speculation barriers..."
	@./$(App_Name) -t ecall -i 100 -m speculation
	@echo "Testing cache flushing..."
	@./$(App_Name) -t ecall -i 100 -m cache
	@echo "Testing timing noise..."
	@./$(App_Name) -t ecall -i 100 -m timing
	@echo "Testing all mitigations..."
	@./$(App_Name) -t ecall -i 100 -m all
	@echo "Mitigation tests completed"

run-tests: test-basic test-mitigations
	@echo "All tests completed successfully"

######## Utility Targets ########
check-sgx:
	@echo "Checking SGX environment..."
	@if [ -d "$(SGX_SDK)" ]; then \
		echo "✓ SGX SDK found at $(SGX_SDK)"; \
	else \
		echo "✗ SGX SDK not found at $(SGX_SDK)"; \
		echo "  Set SGX_SDK environment variable or install Intel SGX SDK"; \
		exit 1; \
	fi
	@if [ -c /dev/isgx ] || [ -c /dev/sgx_enclave ]; then \
		echo "✓ SGX device found"; \
	else \
		echo "⚠ SGX device not found - running in simulation mode"; \
	fi
	@echo "SGX Mode: $(SGX_MODE)"
	@echo "SGX Architecture: $(SGX_ARCH)"
	@echo "Debug Mode: $(SGX_DEBUG)"

install-deps:
	@echo "Installing build dependencies..."
	@sudo apt-get update
	@sudo apt-get install -y build-essential ocaml ocamlbuild automake autoconf \
		libtool wget python libssl-dev git cmake perl libssl-dev libcurl4-openssl-dev \
		protobuf-compiler libprotobuf-dev debhelper cmake reprepro unzip
	@echo "Dependencies installed. Please install Intel SGX SDK separately."

enclave_private.pem:
	@echo "Generating enclave signing key..."
	@openssl genrsa -out $@ -3 3072
	@echo "Generated $@"

$(Enclave_Config_File):
	@echo "Creating enclave configuration..."
	@echo '<EnclaveConfiguration>' > $@
	@echo '  <ProdID>0</ProdID>' >> $@
	@echo '  <ISVSVN>0</ISVSVN>' >> $@
	@echo '  <StackMaxSize>0x40000</StackMaxSize>' >> $@
	@echo '  <HeapMaxSize>0x100000</HeapMaxSize>' >> $@
	@echo '  <TCSNum>10</TCSNum>' >> $@
	@echo '  <TCSPolicy>1</TCSPolicy>' >> $@
	@echo '  <DisableDebug>0</DisableDebug>' >> $@
	@echo '  <MiscSelect>0</MiscSelect>' >> $@
	@echo '  <MiscMask>0xFFFFFFFF</MiscMask>' >> $@
	@echo '</EnclaveConfiguration>' >> $@
	@echo "Generated $@"

######## Cleanup Targets ########
clean-intermediate:
	@rm -f $(Intermediate_Files)
	@echo "Cleaned intermediate files"

clean:
	@rm -f $(App_Name) $(Signed_Enclave_Name) $(Intermediate_Files) \
		test.txt large_test.txt *.csv
	@echo "Cleaned all build artifacts and test files"

clean-all: clean
	@rm -f enclave_private.pem $(Enclave_Config_File)
	@echo "Cleaned everything including generated keys and configs"

######## Help Target ########
help:
	@echo "SGX Mitigation Benchmarking System"
	@echo "=================================="
	@echo ""
	@echo "Build Targets:"
	@echo "  all              - Build application and signed enclave (default)"
	@echo "  $(App_Name)             - Build application only"
	@echo "  $(Signed_Enclave_Name) - Build and sign enclave"
	@echo ""
	@echo "Test Targets:"
	@echo "  test-basic       - Run basic functionality tests"
	@echo "  test-mitigations - Test individual mitigations"
	@echo "  benchmark        - Run comprehensive performance benchmark"
	@echo "  run-tests        - Run all tests"
	@echo ""
	@echo "Utility Targets:"
	@echo "  check-sgx        - Check SGX environment and configuration"
	@echo "  install-deps     - Install build dependencies (Ubuntu/Debian)"
	@echo "  test-files       - Create test files for benchmarking"
	@echo ""
	@echo "Cleanup Targets:"
	@echo "  clean            - Remove build artifacts and test files"
	@echo "  clean-all        - Remove everything including keys and configs"
	@echo "  clean-intermediate - Remove only intermediate build files"
	@echo ""
	@echo "Configuration:"
	@echo "  SGX_SDK=$(SGX_SDK)"
	@echo "  SGX_MODE=$(SGX_MODE)  (HW or SIM)"
	@echo "  SGX_DEBUG=$(SGX_DEBUG) (1 for debug, 0 for release)"

# Ensure required files exist
$(App_Name) $(Signed_Enclave_Name): | enclave_private.pem $(Enclave_Config_File)

# Dependencies
$(App_Objects): $(Generated_Files)
$(Enclave_Objects): $(Generated_Files)

-------------------

